#!/usr/bin/env python3
#*****************************************************************************
#  Name: MTG-Link
#  Description: gap-filling tool for draft genome assemblies, dedicated to 
#  linked read data generated by 10XGenomics Chromium technology.
#  Copyright (C) 2020 INRAE
#  Author: Anne Guichard
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License as
#  published by the Free Software Foundation, either version 3 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Affero General Public License for more details.
#
#  You should have received a copy of the GNU Affero General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#*****************************************************************************

from __future__ import print_function
import os
import sys
import re
import argparse
import gfapy
from gfapy.sequence import rc
from Bio import SeqIO


#----------------------------------------------------
# Arg parser
#----------------------------------------------------
parser = argparse.ArgumentParser(prog="matrix2gfa.py", usage="%(prog)s -in <fasta_file> -matrix <matrix_file> -out <output_directory> -threshold <int>",\
                                formatter_class=argparse.RawTextHelpFormatter, \
                                description=("Transform a file containing the matrix (links between the ends of the contigs) to a GFA file"))

parser.add_argument("-in", dest="input", action="store", help="FASTA file containing the sequences of the contigs obtained from the assembly (format: 'xxx.fasta')", required=True)
parser.add_argument("-matrix", dest="matrix", action="store", help="File containing the links between the ends of the contigs in tabular format", required=True)
parser.add_argument("-threshold", dest="threshold", type=int,  action="store", help="Minimal number of links to be considered", required=False, default=10)
parser.add_argument("-out", dest="outDir", action="store", help="Output directory for saving the GFA file and the corresponding FASTA file", required=True)

args = parser.parse_args()

if re.match('^.*.fasta$', args.input) is None:
    parser.error("The suffix of the input FASTA file should be: '.fasta'")

#----------------------------------------------------
# Input files
#----------------------------------------------------
#FASTA file containing the sequences of the contigs obtained from the assembly
fasta_file = os.path.abspath(args.input)
if not os.path.exists(args.input):
    parser.error("The path of the input FASTA file doesn't exist")
fasta_name = fasta_file.split('/')[-1]
print("\nInput FASTA file: " + fasta_file)
fasta_dict= SeqIO.index(fasta_file, "fasta")

#Matrix file containing the links between the ends of the contigs in tabular format
mat_file = os.path.abspath(args.matrix)
mat_name = (mat_file.split("/")[-1]).split(".matrix")[0]
if not os.path.exists(args.matrix):
        parser.error("The path of the input matrix file doesn't exist")
print("Input matrix file: " + mat_file)

#----------------------------------------------------
# Directory for saving results
#----------------------------------------------------
cwd = os.getcwd()
if not os.path.exists(args.outDir):
    os.mkdir(args.outDir)
try:
    os.chdir(args.outDir)
except:
    print("Something wrong with specified directory. Exception-", sys.exc_info())
    print("Restoring the path")
    os.chdir(cwd)
outDir = os.getcwd()
print("\nThe results are saved in " + outDir)

#----------------------------------------------------
# MATRIX to GFA
#----------------------------------------------------
stored_ctg={}
start_re = re.compile('0-\d+')

try:
    #Output files' names
    fasta_name = outDir + "/" + mat_name+ "."+ "scaffolds.fasta"
    out_fasta = open(fasta_name, "w")
    gfa_file = outDir + "/" + mat_name + ".gfa"

    #Initiate GFA file
    gfa = gfapy.Gfa()
    gfa.add_line("H\tVN:Z:2.0")

    gaps=''

    #Iterate over the links in the matrix file
    with open(mat_file, "r") as mat:
        for line in mat:
            (ctg1,ctg2,links) = line.split(" ")

            #Keep only the links over a certain threshold
            if (int(links) >= args.threshold):
                (ctg1_name, ctg1_pos) = ctg1.split(":")
                (ctg2_name, ctg2_pos) = ctg2.split(":")

                #If both contigs are the same, do not consider this link
                if (ctg1_name == ctg2_name):
                    continue

                #Save the contigs' sequence to the output FASTA and GFA files
                if (not (ctg1_name in stored_ctg)):
                    ctg1_seq = fasta_dict[ctg1_name]
                    ctg1_seq.description='_ len ' + str(len(ctg1_seq))
                    SeqIO.write(ctg1_seq, out_fasta, "fasta")
                    gfa.add_line("S\t{}\t{}\t*\tUR:Z:{}".format(ctg1_name, str(len(ctg1_seq)), fasta_name))          
                    stored_ctg[ctg1_name]=1
                if (not (ctg2_name in stored_ctg)):
                    ctg2_seq = fasta_dict[ctg2_name]
                    ctg2_seq.description='_ len ' + str(len(ctg2_seq))  
                    SeqIO.write(ctg2_seq, out_fasta, "fasta") 
                    gfa.add_line("S\t{}\t{}\t*\tUR:Z:{}".format(ctg2_name, str(len(ctg2_seq)), fasta_name))         
                    stored_ctg[ctg2_name]=1  

                #Find the orientations of both contigs
                #if len(ctg) too short, the orientation of ctg is unknown, it can be 'both' + and -
                ctg1_orient='+'
                ctg2_orient='-'
                if (start_re.match(ctg1_pos)):
                    if (ctg1_pos == "0-" + str(len(fasta_dict[ctg1_name]))):
                        ctg1_orient = 'both'
                    else: 
                        ctg1_orient = '-'
                if (start_re.match(ctg2_pos)):
                    if (ctg2_pos == "0-" + str(len(fasta_dict[ctg2_name]))):
                         ctg2_orient = 'both'
                    else: 
                        ctg2_orient = '+'

                #Orientation of contig1 unknown (it can be 'both' + and -)
                if (ctg1_orient == 'both'):
                    if (ctg2_orient == 'both'):
                        gfa.add_line("G\t*\t{}\t{}\t0\t*".format(ctg1_name + '+', ctg2_name + '+'))
                        gfa.add_line("G\t*\t{}\t{}\t0\t*".format(ctg1_name + '+', ctg2_name + '-'))
                        gfa.add_line("G\t*\t{}\t{}\t0\t*".format(ctg1_name + '-', ctg2_name + '+'))
                        gfa.add_line("G\t*\t{}\t{}\t0\t*".format(ctg1_name + '-', ctg2_name + '-'))
                    else :
                        gfa.add_line("G\t*\t{}\t{}\t0\t*".format(ctg1_name + '+', ctg2_name + ctg2_orient))
                        gfa.add_line("G\t*\t{}\t{}\t0\t*".format(ctg1_name + '-', ctg2_name + ctg2_orient))

                #Orientation of contig2 unknown (it can be 'both' + and -)
                elif (ctg2_orient == 'both'):
                    gfa.add_line("G\t*\t{}\t{}\t0\t*".format(ctg1_name + ctg1_orient, ctg2_name + '+'))
                    gfa.add_line("G\t*\t{}\t{}\t0\t*".format(ctg1_name + ctg1_orient, ctg2_name + '-'))

                #Orientations of both contigs are known
                else:
                    gfa.add_line("G\t*\t{}\t{}\t0\t*".format(ctg1_name + ctg1_orient, ctg2_name + ctg2_orient))

        gfa.to_file(gfa_file)

    print("\nGFA output file: " + gfa_file)
    print("Corresponding file containing all FASTA sequences: " + fasta_name + "\n")


except Exception as e:
    print("\nException-")
    exc_type, exc_tb = sys.exc_info()
    print(exc_type, exc_tb.tb_lineno)
    sys.exit(1)