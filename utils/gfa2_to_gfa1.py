#!/usr/bin/env python3
#*****************************************************************************
#  Name: MTG-Link
#  Description: gap-filling tool for draft genome assemblies, dedicated to 
#  linked read data generated by 10XGenomics Chromium technology.
#  Copyright (C) 2020 INRAE
#  Author: Anne Guichard
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License as
#  published by the Free Software Foundation, either version 3 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Affero General Public License for more details.
#
#  You should have received a copy of the GNU Affero General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#*****************************************************************************

from __future__ import print_function
import os
import sys
import re
import argparse
import gfapy


#----------------------------------------------------
# Arg parser
#----------------------------------------------------
parser = argparse.ArgumentParser(prog="gfa.2_to_gfa.1.py", usage="%(prog)s -in <input_gfa_2.0)> -out <output_directory>", \
                                formatter_class=argparse.RawTextHelpFormatter, \
                                description=("Convert a GFA 2.0 file into a GFA 1.0 file"))

parser.add_argument("-in", dest="input", action="store", help="GFA 2.0 file (format: 'xxx.gfa')", required=True)
parser.add_argument("-out", dest="outDir", action="store", help="Output directory for saving the GFA 1.0 file", required=True)

args = parser.parse_args()

if re.match('^.*.gfa$', args.input) is None:
    parser.error("The suffix of the input GFA file should be: '.gfa'")

#----------------------------------------------------
# Input files
#----------------------------------------------------
input_gfa = os.path.abspath(args.input)
if not os.path.exists(args.input):
    parser.error("The path of the input GFA file doesn't exist")
gfa_name = (input_gfa.split('/')[-1]).split('.gfa')[0]
print("\nInput GFA file: " + input_gfa)

#----------------------------------------------------
# Directory for saving results
#----------------------------------------------------
cwd = os.getcwd()
if not os.path.exists(args.outDir):
    os.mkdir(args.outDir)
try:
    os.chdir(args.outDir)
except:
    print("Something wrong with specified directory. Exception-", sys.exc_info())
    print("Restoring the path")
    os.chdir(cwd)
outDir = os.getcwd()
print("\nThe results are saved in " + outDir)

#----------------------------------------------------
# GFA 2.0 to GFA 1.0
#----------------------------------------------------
try:
    output_gfa = outDir + "/" + gfa_name + "_1.0.gfa"
    path = []
    overlaps = []

    #Open the GFA files
    with open(input_gfa, "r") as f2, open(output_gfa, "a") as f1:
        gfa2 = gfapy.Gfa.from_file(input_gfa)
        gfa1 = gfapy.Gfa.from_file(output_gfa)

        gfa1.add_line("H\tVN:Z:1.0")

        #Iterate over the 'Segment' lines of the input GFA (GFA 2.0) and rewrite them with GFA 1.0 formatting
        for line in gfa2.segments:

            name = str(line).split('\t')[1]
            length = str(line).split('\t')[2]
            sequence_file = str(line).split('\t')[4]

            gfa1.add_line("S\t{}\t*\tLN:i:{}\t{}".format(name, length, sequence_file))

        #Iterate over the 'Edge' lines of the input GFA (GFA 2.0) and rewrite them with GFA 1.0 formatting
        lines = [line for line in gfa2.edges]
        for i in range(len(lines)):

            s1_orient = str(lines[i]).split('\t')[2]
            s1 = "".join(list(s1_orient)[:-1])
            orient1 = list(s1_orient)[-1]
            
            s2_orient = str(lines[i]).split('\t')[3]
            s2 = "".join(list(s2_orient)[:-1])
            orient2 = list(s2_orient)[-1]

            overlap_length = int((str(lines[i]).split('\t')[-2]).split('$')[0]) - int(str(lines[i]).split('\t')[-3])

            gfa1.add_line("L\t{}\t{}\t{}\t{}\t{}M".format(s1, orient1, s2, orient2, overlap_length))

            #Only keep the fwd gapfilled seq to construct the path
            if ("fwd" in s1_orient) or ("fwd" in s2_orient):

                #New path
                if path == []:
                    j = 1
                    if (s1_orient not in path) and (s2_orient not in path):
                        path.append(s1_orient)
                        path.append(s2_orient)

                #Existing path
                else:

                    #Add a 'Path' line to the GFA 1.0 output, end the existing path and start a new path
                    if (s1_orient not in path) and (s2_orient not in path):
                        assembly_path = ','.join(path)
                        assembly_overlaps = ','.join(overlaps)
                        gfa1.add_line("P\tpath{}\t{}\t{}".format(j,assembly_path, assembly_overlaps))
                        path.clear()
                        overlaps.clear()
                        j += 1
                        path.append(s1_orient)
                        path.append(s2_orient)

                    #Prolongation of the existing path
                    elif s1_orient not in path:
                        path.append(s1_orient)
                    elif s2_orient not in path:
                        path.append(s2_orient)

                overlap = str(overlap_length) + "M"
                overlaps.append(overlap)

            #Add a 'Path' line to the GFA 1.0 output and end the existing path
            if i == len(lines)-1:
                assembly_path = ','.join(path)
                assembly_overlaps = ','.join(overlaps)
                gfa1.add_line("P\tpath{}\t{}\t{}".format(j, assembly_path, assembly_overlaps))
                path.clear()
                overlaps.clear()

        gfa1.to_file(output_gfa)


except Exception as e:
    print("\nException-")
    print(e)
    sys.exit(1)