#!/usr/bin/env python3
#*****************************************************************************
#  Name: MTG-Link
#  Description: gap-filling tool for draft genome assemblies, dedicated to 
#  linked read data generated by 10XGenomics Chromium technology.
#  Copyright (C) 2020 INRAE
#  Author: Anne Guichard
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License as
#  published by the Free Software Foundation, either version 3 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Affero General Public License for more details.
#
#  You should have received a copy of the GNU Affero General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#*****************************************************************************

from __future__ import print_function
import os
import sys
import re
import argparse
import gfapy
from gfapy.sequence import rc
from Bio import SeqIO
from Bio import Seq
from libs.segment import Segment
from libs.edge import Edge


#----------------------------------------------------
# Arg parser
#----------------------------------------------------
parser = argparse.ArgumentParser(prog="gfa2fasta.py", usage="%(prog)s -in <gfa_file> -out <output_directory>", \
                                formatter_class=argparse.RawTextHelpFormatter, \
                                description=("Transform a GFA file (GFA 2.0) to a FASTA file (gaps are returned as 'Ns' regions)"))

parser.add_argument("-in", dest="input", action="store", help="GFA 2.0 file (format: 'xxx.gfa')", required=True)
parser.add_argument("-out", dest="outDir", action="store", help="Output directory for saving the FASTA file", required=True)

args = parser.parse_args()

if re.match('^.*.gfa$', args.input) is None:
    parser.error("The suffix of the input GFA file (GFA 1.0) should be: '.gfa'")

#----------------------------------------------------
# Input files
#----------------------------------------------------
#GFA 2.0 file
gfa_file = os.path.abspath(args.input)
if not os.path.exists(args.input):
    parser.error("The path of the input GFA file doesn't exist")
gfa_name = gfa_file.split('/')[-1]
print("\nInput GFA file: " + gfa_file,file=sys.stderr )

#----------------------------------------------------
# Directory for saving results
#----------------------------------------------------
cwd = os.getcwd()
if not os.path.exists(args.outDir):
    os.mkdir(args.outDir)
try:
    os.chdir(args.outDir)
except:
    print("Something wrong with specified directory. Exception-", sys.exc_info())
    print("Restoring the path")
    os.chdir(cwd)
outDir = os.getcwd()
print("The results are saved in " + outDir, file=sys.stderr)

#----------------------------------------------------
# GFA 2.0 to FASTA
#----------------------------------------------------
try:
    seq_dict = {}
    segments = {}
    edges = []

    #Open the input GFA file
    with open(gfa_file, "r") as f:
        gfa = gfapy.Gfa.from_file(gfa_file)

        #Store the segments in the dict 'segments' 
        for line in gfa.segments:
            seq_name = str(line).split('\t')[1]
            seq_file = str(line).split('\t')[4].split(":")[2]
            #If the segment's sequence is not in the dict 'seq_dict', add it to this dictionary
            if not seq_file in seq_dict:
                seq_dict[seq_file] = SeqIO.to_dict(SeqIO.parse(seq_file, "fasta"))

            #Append the dict 'segments' with the current segments
            segments[seq_name] = Segment(seq_name, seq_dict[seq_file][seq_name])

        #Store the edges in the list 'edges'
        for line in gfa.edges:
            #s1,s2: seq names
            s1 = str(line).split('\t')[2][:-1]
            s2 = str(line).split('\t')[3][:-1]
            #o1,o2: orientations of s1,s2 resp.
            o1 = str(line).split('\t')[2][-1:]
            o2 = str(line).split('\t')[3][-1:]

            #b1: beginning position of s1
            b1 = int(str(line).split('\t')[4])
            #e1: ending position of s1 (remove the '$' sign if any)
            e1 = str(line).split('\t')[5]
            if (e1[-1:] == '$'):
                e1 = e1[:-1]
            e1 = int(e1) 

            #b2: beginning position of s2
            b2 = int(str(line).split('\t')[6])
            #e2: ending position of s2 (remove the '$' sign if any)
            e2 = str(line).split('\t')[7]
            if (e2[-1:] == '$'):
                e2 = e2[:-1]
            e2 = int(e2) 
            
            #new variable 'edge' representing the current edge
            edge = Edge(segments[s1],o1,segments[s2],o2,b1,e1,b2,e2)
            
            #Add the 'edge' to the list of edges linking s1 in orientation '+'
            if (o1 == '+'):
                segments[s1].add_link(edge, 'plus')
                o1prim = '-'
            #Add the 'edge' to the list of edges linking s1 in orientation '-'
            if (o1 == '-'):
                segments[s1].add_link(edge, 'minus')
                o1prim = '+'

            #Add an 'edgeprim' to the list of edges linking s2 in orientation '-':
            if (o2 == '+'):
                edgeprim = Edge(segments[s2],'-',segments[s1],o1prim,b2,e2,b1,e1)   
                segments[s2].add_link(edgeprim, 'minus') 
            #Add an 'edgeprim' to the list of edges linking s2 in orientation '+':
            if (o2 == '-'):
                edgeprim = Edge(segments[s2],'+',segments[s1],o1prim,b2,e2,b1,e1)   
                segments[s2].add_link(edgeprim, 'plus') 
            

        #PATHS creation
        seen = {}
        mtg_scaffold_num = 0

        #Iterate over the segments
        for sname in segments.keys():

            #If the current segment hasn't been processed yet, do it
            if not sname in seen:
                s = segments[sname]

                #We go to the most left segments from this one
                sens = '-'
                cont = 1 
                while (cont):
                    if (sens == '+'):  
                        if (len(s.plus) != 0):
                            sens=s.plus[0].orientation2
                            s=s.plus[0].segment2
                        else:
                            cont=0

                    if (sens == '-'):  
                        if (len(s.minus) != 0):
                            sens=s.minus[0].orientation2
                            s=s.minus[0].segment2
                        else:
                            cont=0

                # We go on the opposite direction
                if (sens == '+'):
                    sens = '-'
                    mtg_scaffold=s.seq.reverse_complement()
                else :
                    sens='+'
                    mtg_scaffold=s.seq    

                mtg_scaffold_num+=1
                
                mtg_scaffold.id="mtg_scaffold_"+str(mtg_scaffold_num)
                mtg_scaffold.description=s.name + sens
                print(mtg_scaffold.id, file=sys.stderr)
                print(s.name + sens, file=sys.stderr)
                seen[s.name]=True
                cont=1

                while (cont):
                    if (sens =='+'):  
                        if (len(s.plus) != 0):
                            sens=s.plus[0].orientation2
                            if (sens == "+"):
                                if (s.plus[0].begin2 != 0):
                                    exit("Error uncorrect link ++ " + str(s.plus[0].begin2) + "**" + s.plus[0].segment1.name + " - " +  s.plus[0].segment2.name)
                                mtg_scaffold.seq=mtg_scaffold.seq+s.plus[0].segment2.seq[s.plus[0].end2:].seq
                            else:
                                if (s.plus[0].begin2 == 0):
                                    exit("Error uncorrect link +-" + s.plus[0].segment1.name  + " - " +  s.plus[0].segment2.name)
                                mtg_scaffold.seq=mtg_scaffold.seq+s.plus[0].segment2.seq[:s.plus[0].begin2].reverse_complement().seq

                            
                            #print(mtg_scaffold, file=sys.stderr)
                            
                            s=s.plus[0].segment2
                            mtg_scaffold.description=mtg_scaffold.description+"--"+s.name+sens
                            seen[s.name]=True
                            print(s.name + sens, file=sys.stderr)

                        else:
                            cont=0

                    if (sens =='-'):  
                        if (len(s.minus) != 0):
                            sens=s.minus[0].orientation2
                            if (sens == "+"):
                                if (s.minus[0].begin2 != 0):
                                    exit("Error uncorrect link -+" + s.minus[0].segment1.name + " - " +  s.minus[0].segment2.name)
                                mtg_scaffold.seq=mtg_scaffold.seq+s.minus[0].segment2.seq[s.minus[0].end2:].seq
                            else:
                                if (s.minus[0].begin2 == 0):
                                    exit("Error uncorrect link -- " + s.minus[0].segment1.name + " - " +  s.minus[0].segment2.name)
                                mtg_scaffold.seq=mtg_scaffold.seq+s.minus[0].segment2.seq[:s.minus[0].begin2].reverse_complement().seq
                            
                            s=s.minus[0].segment2
                            seen[s.name]=True
                            mtg_scaffold.description=mtg_scaffold.description+"--"+s.name+sens
                            print(s.name + sens, file=sys.stderr)
                        else:
                            cont=0
                SeqIO.write(mtg_scaffold,  sys.stdout, "fasta") 


except Exception as e:
    print("\nException-")
    print(e)
    sys.exit(1)